/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package triton;

import PNGtoMSX.ConvertNonEmptyPatternsToAssembler;
import PNGtoMSX.FindAllTiles;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;
import util.APLib;
import util.Pletter;
import util.Z80Assembler;


/**
 *
 * @author santi
 */
public class BossData {
    static public int TOLERANCE = 32;
    
    public static void main(String args[]) throws Exception
    {
        polyphemus(args);
        scylla(args);
        charybdis(args);
        triton(args);
    }


    public static void polyphemus(String args[]) throws Exception
    {
        // sprites:
        BufferedImage img = ImageIO.read(new File("data/boss1-polyphemus-sprites.png"));
        List<int[]> sprites = ExtractSprites.extractSprites(img);
        System.out.println("# sprites: " + sprites.size());
        //ExtractSprites.saveSprites(sprites, "src/autogenerated", "boss1-sprites");        
        
        
        String outputFolder = "src/autogenerated";
        
        // These are tiles for graphics to draw OVER the map (e.g. shurikens):
        List<List<Integer>> tiles = new ArrayList<>();
        //List<Integer> empty_tile = new ArrayList<>();
        //for(int i = 0;i<16*16;i++) empty_tile.add(0);
        //tiles.add(empty_tile);
        int base_n_tiles = 43;
        System.out.println("Total additional tiles: " + base_n_tiles);
                
        // Generate boss tiles:
        int nametable[][] = extractTiles("data/boss1-polyphemus.png", 
                                         "data/boss1-polyphemus-tile-types.png",
                                         GenerateTileSets.FIRST_COLLIDABLE_TILE, 
                                         base_n_tiles-1, tiles);
        FindAllTiles.saveTilesToPNG(tiles, "src/autogenerated/boss1-polyphemus-tiles.png");
        
        System.out.println("Total tiles: " + tiles.size());
        
        for(int i = 0;i<nametable[0].length;i++) {
            for(int j = 0;j<nametable.length;j++) {
                if (nametable[j][i] > 0) nametable[j][i] += base_n_tiles-1;
                System.out.print(nametable[j][i] + "\t");
            }
            System.out.println("");
        }
        
        // Save the tile bank:
        {
            String fileName = outputFolder + "/boss1-tiles";
            saveTileBank(fileName + ".asm", tiles, 1);
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});     
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        
        // Extract and save boss positions nametables:
        {
            List<Integer> data = new ArrayList<>();
            // main body:
            addNameTableChunk(1,0,8,7, nametable, data);

            // thruster:
            addNameTableChunk(17,5,1,3, nametable, data);
            
            // eye frames:
            addNameTableChunk(11,1,2,3, nametable, data);
            addNameTableChunk(9,1,2,3, nametable, data);
            addNameTableChunk(1,2,2,3, nametable, data);
            addNameTableChunk(10,6,2,3, nametable, data);
            addNameTableChunk(12,6,2,3, nametable, data);
            addNameTableChunk(14,6,2,3, nametable, data);
            
            // arms:
            addNameTableChunk(18,0,6,5, nametable, data);
            addNameTableChunk(18,4,6,5, nametable, data);
            
            // legs:
            addNameTableChunk(1,9,4,4, nametable, data);
            addNameTableChunk(5,9,4,4, nametable, data);
            
            // laser:
            addNameTableChunk(14,3,1,1, nametable, data);
            
            System.out.println("data before sprites: " + data.size());
            
            // add the sprite data:
            for(int sprite[]:sprites) {
                for(int b:sprite) data.add(b);
            }

            String fileName = outputFolder + "/boss1-data";
            FileWriter fw = new FileWriter(new File(fileName + ".asm"));
            fw.write("    org #0000\n\n");
            Z80Assembler.dataBlockToAssembler(data, "bg", fw, 32);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"}); 
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
    }
    
    
    public static void scylla(String args[]) throws Exception
    {
        // sprites:
        BufferedImage img = ImageIO.read(new File("data/boss2-scylla-sprites.png"));
        List<int[]> sprites = ExtractSprites.extractSprites(img);
        System.out.println("# sprites: " + sprites.size());
        // ExtractSprites.saveSprites(sprites, "src/autogenerated", "boss2-sprites");        
        
        
        String outputFolder = "src/autogenerated";
        
        // These are tiles for graphics to draw OVER the map (e.g. shurikens):
        List<List<Integer>> tiles = new ArrayList<>();
        //List<Integer> empty_tile = new ArrayList<>();
        //for(int i = 0;i<16*16;i++) empty_tile.add(0);
        //tiles.add(empty_tile);
        int base_n_tiles = 43;
        System.out.println("Total additional tiles: " + base_n_tiles);
                
        // Generate boss tiles:
        int nametable[][] = extractTiles("data/boss2-scylla.png", 
                                         "data/boss2-scylla-tile-types.png",
                                         GenerateTileSets.FIRST_COLLIDABLE_TILE, 
                                         base_n_tiles-1, tiles);
        FindAllTiles.saveTilesToPNG(tiles, "src/autogenerated/boss2-scylla-tiles.png");
        
        System.out.println("Total tiles: " + tiles.size());
        
        for(int i = 0;i<nametable[0].length;i++) {
            for(int j = 0;j<nametable.length;j++) {
                if (nametable[j][i] > 0) nametable[j][i] += base_n_tiles-1;
                System.out.print(nametable[j][i] + "\t");
            }
            System.out.println("");
        }
        
        // Save the tile bank:
        {
            String fileName = outputFolder + "/boss2-tiles";
            saveTileBank(fileName + ".asm", tiles, 1);
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        
        // Extract and save boss positions nametables:
        {
            List<Integer> data = new ArrayList<>();
            // bottom body:
            addNameTableChunk(0,3,9,5, nametable, data);    
            addNameTableChunk(0,11,9,5, nametable, data);

            // red light:
            addNameTableChunk(1,8,2,1, nametable, data);

            // thruster:
            addNameTableChunk(0,8,1,1, nametable, data);
            addNameTableChunk(0,9,1,1, nametable, data);
            addNameTableChunk(0,10,1,1, nametable, data);
            
            // head:
            addNameTableChunk(9,0,8,7, nametable, data);    // eyes closed
            addNameTableChunk(18,0,8,7, nametable, data);   // eyes open
            addNameTableChunk(26,0,8,7, nametable, data);   // pushing forward
            addNameTableChunk(36,0,8,7, nametable, data);   // opening mouth

            // jaw:
            addNameTableChunk(39,11,3,1, nametable, data);
            addNameTableChunk(36,11,3,3, nametable, data);

            // spider body:
            addNameTableChunk(17,7,9,4, nametable, data);
            addNameTableChunk(17,11,9,4, nametable, data);
            addNameTableChunk(27,7,9,4, nametable, data);

            // laser:
            addNameTableChunk(3,8,1,1, nametable, data);

            System.out.println("data before sprites: " + data.size());
            
            // add the sprite data:
            for(int sprite[]:sprites) {
                for(int b:sprite) data.add(b);
            }            
            
            String fileName = outputFolder + "/boss2-data";
            FileWriter fw = new FileWriter(new File(fileName + ".asm"));
            fw.write("    org #0000\n\n");
            Z80Assembler.dataBlockToAssembler(data, "bg", fw, 32);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
    }    
    
    
    public static void charybdis(String args[]) throws Exception
    {
        // sprites:
        BufferedImage img = ImageIO.read(new File("data/boss3-charybdis-sprites.png"));
        List<int[]> sprites = ExtractSprites.extractSprites(img);
        System.out.println("# sprites: " + sprites.size());
        
        String outputFolder = "src/autogenerated";
        
        // These are tiles for graphics to draw OVER the map (e.g. shurikens):
        List<List<Integer>> tiles = new ArrayList<>();
        int base_n_tiles = 43;
        System.out.println("Total additional tiles: " + base_n_tiles);
                
        // Generate boss tiles:
        int nametable[][] = extractTiles("data/boss3-charybdis.png", 
                                         "data/boss3-charybdis-tile-types.png",
                                         GenerateTileSets.FIRST_COLLIDABLE_TILE, 
                                         base_n_tiles-1, tiles);
        FindAllTiles.saveTilesToPNG(tiles, "src/autogenerated/boss3-charybdis-tiles.png");
        
        System.out.println("Total tiles: " + tiles.size());
        
        for(int i = 0;i<nametable[0].length;i++) {
            for(int j = 0;j<nametable.length;j++) {
                if (nametable[j][i] > 0) nametable[j][i] += base_n_tiles-1;
                System.out.print(nametable[j][i] + "\t");
            }
            System.out.println("");
        }
        
        // Save the tile bank:
        {
            String fileName = outputFolder + "/boss3-tiles";
            saveTileBank(fileName + ".asm", tiles, 1);
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        
        // Extract and save boss positions nametables:
        {
            List<Integer> data = new ArrayList<>();
            // head:
            addNameTableChunk(0,1,4,3, nametable, data);
            addNameTableChunk(0,5,3,4, nametable, data);    
            addNameTableChunk(0,10,3,4, nametable, data);    
            addNameTableChunk(4,12,4,4, nametable, data);    
            
            // body straight + 3*4*3+4*4
            addNameTableChunk(5,0,1,3, nametable, data);    // <--
            addNameTableChunk(6,0,1,3, nametable, data);    // <--
            addNameTableChunk(5,4,3,1, nametable, data);    // ^^^
            addNameTableChunk(5,5,3,1, nametable, data);    // ^^^
            addNameTableChunk(5,8,3,1, nametable, data);    // vvv
            addNameTableChunk(5,9,3,1, nametable, data);    // vvv

            // tail + 3*4*3+4*4 + 3*1*6
            addNameTableChunk(9,0,3,3, nametable, data);    // <--
            addNameTableChunk(9,4,3,3, nametable, data);    // ^^^
            addNameTableChunk(9,8,3,3, nametable, data);    // vvv
            
            // curving body: + 3*4*3+4*4 + 3*1*6 + 3*3*3
            addNameTableChunk(13,0,4,4, nametable, data);    // /-
            addNameTableChunk(22,0,4,4, nametable, data);    // /-
            addNameTableChunk(17,0,4,4, nametable, data);    // -\
            addNameTableChunk(26,0,4,4, nametable, data);    // =\
            addNameTableChunk(13,5,4,4, nametable, data);    // \-
            addNameTableChunk(22,5,4,4, nametable, data);    // \-
            addNameTableChunk(17,5,4,4, nametable, data);    // -/
            addNameTableChunk(26,5,4,4, nametable, data);    // -/

            // face: + 3*4*3+4*4 + 3*1*6 + 3*3*3 + 4*4*8
            addNameTableChunk(10,13,2,3, nametable, data);
            addNameTableChunk(12,13,2,3, nametable, data);
            
            // laser: + 3*4*3+4*4 + 3*1*6 + 3*3*3 + 4*4*8 + 2*3*2
            addNameTableChunk(0,15,1,1, nametable, data);

            System.out.println("data before sprites: " + data.size());
            
            // add the sprite data:
            for(int sprite[]:sprites) {
                for(int b:sprite) data.add(b);
            }            
            
            String fileName = outputFolder + "/boss3-data";
            FileWriter fw = new FileWriter(new File(fileName + ".asm"));
            fw.write("    org #0000\n\n");
            Z80Assembler.dataBlockToAssembler(data, "bg", fw, 32);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
    }        
    
    
    public static void triton(String args[]) throws Exception
    {
        // sprites:
        BufferedImage img = ImageIO.read(new File("data/boss4-triton-sprites.png"));
        List<int[]> sprites = ExtractSprites.extractSprites(img);
        System.out.println("# sprites: " + sprites.size());
        
        String outputFolder = "src/autogenerated";
        
        // These are tiles for graphics to draw OVER the map (e.g. shurikens):
        List<List<Integer>> tiles = new ArrayList<>();
        int base_n_tiles = 43;
        System.out.println("Total additional tiles: " + base_n_tiles);
                
        // Generate boss tiles:
        int nametable[][] = extractTiles("data/boss4-triton.png", 
                                         "data/boss4-triton-tile-types.png",
                                         GenerateTileSets.FIRST_COLLIDABLE_TILE, 
                                         base_n_tiles-1, tiles);
        FindAllTiles.saveTilesToPNG(tiles, "src/autogenerated/boss4-triton-tiles.png");
        
        System.out.println("Total tiles: " + tiles.size());
        
        for(int i = 0;i<nametable[0].length;i++) {
            for(int j = 0;j<nametable.length;j++) {
                if (nametable[j][i] > 0) nametable[j][i] += base_n_tiles-1;
                System.out.print(nametable[j][i] + "\t");
            }
            System.out.println("");
        }
        
        // Save the tile bank:
        {
            String fileName = outputFolder + "/boss4-tiles";
            saveTileBank(fileName + ".asm", tiles, 1);
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        
        // Extract and save boss positions nametables:
        {
            List<Integer> data = new ArrayList<>();
            // head:
            addNameTableChunk(1,0,7,8, nametable, data);
            addNameTableChunk(1,8,7,8, nametable, data);
            addNameTableChunk(1,16,7,8, nametable, data);
            
            // hump: + 7*8*3
            addNameTableChunk(8,1,5,7, nametable, data);

            // body: + 7*8*3 + 5*7
            addNameTableChunk(13,0,14,8, nametable, data);
            addNameTableChunk(12,9,15,7, nametable, data);
            addNameTableChunk(12,17,15,7, nametable, data);
            addNameTableChunk(30,9,13,7, nametable, data);
            addNameTableChunk(29,17,14,7, nametable, data);
            addNameTableChunk(34,17,9,7, nametable, data);
            
            // vertical trident: + 7*8*3 + 5*7 + 14*8+15*7*2 + 13*7 + 14*7 + 9*7
            addNameTableChunk(29,3,2,6, nametable, data);
            // horizontal trident: + 7*8*3 + 5*7 + 14*8+15*7*2 + 13*7 + 14*7 + 9*7 + 2*6
            addNameTableChunk(31,0,13,3, nametable, data);
            
            System.out.println("data before sprites: " + data.size());
            
            // add the sprite data:
            for(int sprite[]:sprites) {
                for(int b:sprite) data.add(b);
            }            
            
            String fileName = outputFolder + "/boss4-data";
            FileWriter fw = new FileWriter(new File(fileName + ".asm"));
            fw.write("    org #0000\n\n");
            Z80Assembler.dataBlockToAssembler(data, "bg", fw, 32);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
    }   
    
    
    public static void addNameTableChunk(int x0, int y0, int w, int h, int nametable[][], List<Integer> data)
    {
        for(int i = y0;i<y0+h;i++) {
            for(int j = x0;j<x0+w;j++) {
                data.add(nametable[j][i]);
            }
        }
    }
    
    
    private static int[][] extractTiles(String fileName, String tileTypesFileName,
                                        int first_collidable_tile[],
                                        int n_base_tiles,
                                        List<List<Integer>> tiles) throws Exception {
        BufferedImage img = ImageIO.read(new File(fileName));
        BufferedImage img_types = ImageIO.read(new File(tileTypesFileName));
        int w = img.getWidth()/8;
        int h = img.getHeight()/8;
        int nametable[][] = new int[w][h];
        List<List<Integer>> tiles_perCollisionType[] = new List[5];
        for(int i = 0;i<5;i++) {
            tiles_perCollisionType[i] = new ArrayList<>();
        }
        
        System.out.println(fileName + ": " + w + " x " + h);
        
        int accum = 0;
        for(int i = 0;i<h;i++) {
            for(int j = 0;j<w;j++) {
                List<Integer> tile = FindAllTiles.getTile(img, j, i, TOLERANCE);
                int collisionType = GenerateTileSets.getTileCollisionType(img_types, j*8, i*8);
                
                int found = -1;
                for(int idx = 0;idx<tiles_perCollisionType[collisionType].size();idx++) {
                    List<Integer> t2 = tiles_perCollisionType[collisionType].get(idx);
                    boolean equals = true;
                    for(int k = 0;k<tile.size();k++) {
                        if (!t2.get(k).equals(tile.get(k))) {
                            equals = false;
                            break;
                        }
                    }
                    if (equals) {
                        found = idx;
                        break;
                    }
                }
                if (found == -1) {
                    // found = tiles_perCollisionType[collisionType].size();
                    tiles_perCollisionType[collisionType].add(tile);
                    accum++;
                }
                
                System.out.print((found == -1 ? "*":"-"));
                // nametable[j][i] = found;
            }                       
            System.out.println("");
        }

        // reorder the tiles by collision type:
        for(int i = 0;i<5;i++) {
            tiles.addAll(tiles_perCollisionType[i]);
            int n = tiles.size()+n_base_tiles;
            System.out.println(n + " vs " + first_collidable_tile[i+1]); 
            if (n > first_collidable_tile[i+1]) {
                throw new Exception("Too many tiles of type " + i + " (" + tiles_perCollisionType[i].size() + ")");
            } else {
                if (i<4) {
                    System.out.println("collision type 0: " + n + ", padding to " + first_collidable_tile[i+1]);
                    while(tiles.size()+n_base_tiles < first_collidable_tile[i+1]) {
                        List<Integer> empty_tile = new ArrayList<>();
                        for(int j = 0;j<8*8;j++) {
                            empty_tile.add(0);
                        }
                        tiles.add(empty_tile);
                    }
                }
            }
        }
        
        // reconstruct the name table:
        for(int i = 0;i<h;i++) {
            for(int j = 0;j<w;j++) {
                List<Integer> tile = FindAllTiles.getTile(img, j, i, TOLERANCE);
                
                int found = -1;
                for(int idx = 0;idx<tiles.size();idx++) {
                    List<Integer> t2 = tiles.get(idx);
                    boolean equals = true;
                    for(int k = 0;k<tile.size();k++) {
                        if (!t2.get(k).equals(tile.get(k))) {
                            equals = false;
                            break;
                        }
                    }
                    if (equals) {
                        found = idx;
                        break;
                    }
                }
                nametable[j][i] = found;
            }                       
        }
        
        return nametable;
    }
 
    
    public static void saveTileBank(String outputFile, List<List<Integer>> tiles, int n_tiles_to_skip) throws Exception {
        FileWriter fw = new FileWriter(new File(outputFile));

        fw.write("    org #0000\n\n");
        
        int banksize = (tiles.size()-n_tiles_to_skip)*8;
        fw.write("    dw " + banksize + "\n");
        fw.write("patterns:\n");
        for(int tile_idx = n_tiles_to_skip;tile_idx<tiles.size(); tile_idx++) {
            List<Integer> tile = tiles.get(tile_idx);
            List<Integer> data = new ArrayList<>();
            for(int line = 0;line<8;line++) {
                List<Integer> pixels = new ArrayList<>();
                for(int j = 0;j<8;j++) {
                    pixels.add(tile.get(line*8+j));
                }
                data.add(ConvertNonEmptyPatternsToAssembler.generateAssemblerBitmapLine(pixels));
            }
            Z80Assembler.dataBlockToAssembler(data, "tile_" + tile_idx, fw, 8);
        }
        fw.write("patternattributes:\n");
        for(int tile_idx = n_tiles_to_skip;tile_idx<tiles.size(); tile_idx++) {
            List<Integer> tile = tiles.get(tile_idx);
            List<Integer> data = new ArrayList<>();
            for(int line = 0;line<8;line++) {
                List<Integer> pixels = new ArrayList<>();
                for(int j = 0;j<8;j++) {
                    pixels.add(tile.get(line*8+j));
                }
                data.add(ConvertNonEmptyPatternsToAssembler.generateAssemblerAttributesLine(pixels));
            }
            Z80Assembler.dataBlockToAssembler(data, "tileattributes_" + tile_idx, fw, 8);
        }
        fw.flush();
        fw.close();
    }    
}
