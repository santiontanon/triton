/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package triton;

import PNGtoMSX.ConvertNonEmptyPatternsToAssembler;
import PNGtoMSX.FindAllTiles;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.imageio.ImageIO;
import triton.pcg.Pattern;
import PNGtoMSX.ConvertPatternsToAssembler;
import java.io.FileWriter;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import util.APLib;
import util.Pletter;
import util.Z80Assembler;

/**
 *
 * @author santi
 */
public class GenerateTileSets {
    static public int TOLERANCE = 32;
    static public int NBANKS = 2;
    static public int BANK_START[] = {0, 8};
    static public int BANK_HEIGHT[] = {8, 14};
    static public int MAP_HEIGHT = 22;
    
    static public int SOLID_BLACK_BG_TILE = 252;
    static public int TILE_ENEMY_FIRST_TILE = 253;
    
    public static int MSX1Palette[][]={
                                {0,0,0},              // Transparent
                                {0,0,0},              // Black
                                {36,219,36},          // Medium Green
                                {109,255,109},        // Light Green
                                {36,36,255},          // Dark Blue
                                {73,109,255},         // Light Blue
                                {182,36,36},          // Dark Red
                                {73,219,255},         // Cyan
                                {255,36,36},          // Medium Red
                                {255,109,109},        // Light Red
                                {219,219,36},         // Dark Yellow
                                {219,219,146},        // Light Yellow
                                {36,146,36},          // Dark Green
                                {219,73,182},         // Magenta
                                {182,182,182},        // Grey
                                {255,255,255}};       // White        
    
    // If we don't have at least this many tiles free in each bank, give an error
    static public int RESERVED_TILES_FOR_TEXT[] = {16,0};
    
//    static public int FIRST_COLLIDABLE_TILE[] = {0, 72, 73, 194, 196, 250};
    static public int FIRST_COLLIDABLE_TILE[] = {0, 72, 73, 205, 207, 250};
    
        
    static public boolean print_TileTypeTable = false;
    

    public static class TileType {
        int tile;
        int nextTileH;
        int tileTableH[] = null;
        int collision;
        
        
        public TileType(int t, int nth, int c) {
            tile = t;
            nextTileH = nth;   
            collision = c;
            // if (tile == 11 && nextTileH == 0) throw new Error("WTF-TileType!");
        }
        
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof TileType)) return false;
            TileType tt = (TileType)o;
            if (tile != tt.tile ||
                nextTileH != tt.nextTileH) return false;
            return true;
        }
        
        @Override
        public String toString() {
            return tile + "->" + nextTileH + " [" + collision + "]";
        }
    }    
    
    
    public static class InstantiatedTileType {
        TileType type;
        int offset;
        
        public InstantiatedTileType(TileType t, int os)
        {
            type = t;
            offset = os;
        }
    }
        
    
    public static void main(String args[]) throws Exception {
        ConvertPatternsToAssembler.MSX1Palette = MSX1Palette;
        List<List<Integer>> usedBaseTiles = new ArrayList<>();
        
        // moai:
        {
            HashMap<Integer,Integer> mapToEquivalentTile = new LinkedHashMap<>();        
            generateTileTypes(mapToEquivalentTile, usedBaseTiles, "moai");
            String filename = "src/autogenerated/moai/bankTileTypes";
            nl.grauw.glass.Assembler.main(new String[]{filename + ".asm", filename + ".bin"});
            Pletter.intMain(new String[]{filename + ".bin", filename + ".plt"});            
            APLib.main(filename + ".bin", filename + ".apl", true);
        }
        
        // tech:
        {
            HashMap<Integer,Integer> mapToEquivalentTile = new LinkedHashMap<>();        
            generateTileTypes(mapToEquivalentTile, usedBaseTiles, "tech");
            String filename = "src/autogenerated/tech/bankTileTypes";
            nl.grauw.glass.Assembler.main(new String[]{filename + ".asm", filename + ".bin"});
            Pletter.intMain(new String[]{filename + ".bin", filename + ".plt"});
            APLib.main(filename + ".bin", filename + ".apl", true);
        }
        
        // water:
        {
            HashMap<Integer,Integer> mapToEquivalentTile = new LinkedHashMap<>();        
            generateTileTypes(mapToEquivalentTile, usedBaseTiles, "water");
            String filename = "src/autogenerated/water/bankTileTypes";
            nl.grauw.glass.Assembler.main(new String[]{filename + ".asm", filename + ".bin"});
            Pletter.intMain(new String[]{filename + ".bin", filename + ".plt"});
            APLib.main(filename + ".bin", filename + ".apl", true);
        }    

        // temple:
        {
            HashMap<Integer,Integer> mapToEquivalentTile = new LinkedHashMap<>();        
            generateTileTypes(mapToEquivalentTile, usedBaseTiles, "temple");
            String filename = "src/autogenerated/temple/bankTileTypes";
            nl.grauw.glass.Assembler.main(new String[]{filename + ".asm", filename + ".bin"});
            Pletter.intMain(new String[]{filename + ".bin", filename + ".plt"});
            APLib.main(filename + ".bin", filename + ".apl", true);
        }    

    }

    
    public static List<TileType>[] generateTileTypes(
            HashMap<Integer,Integer> mapToEquivalentTile, 
            List<List<Integer>> usedBaseTiles,
            String mapTypeName) throws Exception
    {        
        HashMap<Integer,int[]> animatedTiles = new HashMap<>();
     
        if (mapTypeName.equals("tech")) {
            animatedTiles.put(240, new int[]{240,241,242,243});
        }
        if (mapTypeName.equals("water")) {
            animatedTiles.put(128, new int[]{128,129,130,131});
            animatedTiles.put(144, new int[]{144,145,146,147});
            animatedTiles.put(160, new int[]{160,161,162,163});
            animatedTiles.put(176, new int[]{176,177,178,179});
            animatedTiles.put(192, new int[]{192,193,194,195});
        }
        if (mapTypeName.equals("temple")) {
            animatedTiles.put(240, new int[]{240,241,242,243});
        }
        
        Pattern powerPelletPattern = new Pattern("data/patterns/power-pellet.tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{});
        List<Pattern> patterns = new ArrayList<>();
        patterns.add(new Pattern("data/patterns/"+mapTypeName+"-all-tiles-auto.tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));

        // Additional tiles used by the game (explosions, stars, etc.):
        List<List<Integer>> baseAdditionalTiles = new ArrayList<>();
        List<List<Integer>> scoreboardAdditionalTiles = new ArrayList<>();
        {
            findAllTilesWithTypes(ImageIO.read(new File("data/additional-tiles-base.png")), null, baseAdditionalTiles, null, null, true);
            baseAdditionalTiles.remove(baseAdditionalTiles.get(0));
            System.out.println("Found # additional tiles in additional-tiles-base.png: " + baseAdditionalTiles.size());        
            findAllTilesWithTypes(ImageIO.read(new File("data/additional-tiles-scoreboard.png")), null, scoreboardAdditionalTiles, null, null, true);
            scoreboardAdditionalTiles.remove(scoreboardAdditionalTiles.get(0));
            System.out.println("Found # additional tiles in additional-tiles-scoreboard.png: " + scoreboardAdditionalTiles.size());        
        }
        
        List<List<Integer>> additionalTiles[] = new List[NBANKS];
        additionalTiles[0] = new ArrayList<>();
        additionalTiles[0].addAll(baseAdditionalTiles);
        
        additionalTiles[1] = new ArrayList<>();
        additionalTiles[1].addAll(baseAdditionalTiles);
        additionalTiles[1].addAll(scoreboardAdditionalTiles);
        
        return processPatterns("data/patterns/"+mapTypeName+"-tiles.png", 
                               "data/patterns/"+mapTypeName+"-tile-types.png", patterns, powerPelletPattern,
                               "src/autogenerated/"+mapTypeName, "src/autogenerated",
                               additionalTiles, mapToEquivalentTile, usedBaseTiles, false,
                               animatedTiles,
                               mapTypeName);
    }
    
   
    public static List<TileType>[] processPatterns(String tilesFile, String tilesTypeFile, 
                                   List<Pattern> patterns, Pattern powerPelletPattern,
                                   String outputFolder, String outputFolderParent,
                                   List<List<Integer>> additionalTiles[],
                                   HashMap<Integer,Integer> mapToEquivalentTile,
                                   List<List<Integer>> usedBaseTiles,
                                   boolean justObtainTileTypes,
                                   HashMap<Integer,int[]> animatedTiles,
                                   String prefix) throws Exception 
    {
        // Find all the base tiles:
        BufferedImage img = ImageIO.read(new File(tilesFile));
        BufferedImage imgCollisions = ImageIO.read(new File(tilesTypeFile));

        List<List<Integer>> baseTiles = new ArrayList<>();
        List<Integer> baseTileCollision = new ArrayList<>(); // 0: background, 1: collidable, 2: enemy
        List<List<Integer>> usedTiles[] = new List[NBANKS];
        List<InstantiatedTileType> usedTileTypes[] = new List[NBANKS];
        List<TileType> bankTileTypes[] = new List[NBANKS];
        //int bank_size_in_bytes[] = {0,0};
        for(int i = 0;i<NBANKS;i++) {
            bankTileTypes[i] = new ArrayList<>();
        }
        
        // find map tiles:        
        findAllTilesWithTypes(img, imgCollisions, baseTiles, baseTileCollision, mapToEquivalentTile, false);
        System.out.println("Found # tiles in png: " + baseTiles.size());
        System.out.println("baseTileCollision: " + baseTileCollision);        
                
        // start with the additional tiles:
        for(int i = 0;i<NBANKS;i++) {
            usedTiles[i] = new ArrayList<>();
            usedTileTypes[i] = new ArrayList<>();
            
            // make sure that the 0 to 0 tile is the first:
            bankTileTypes[i].add(new TileType(0, 0, 0));
            for(int additional_idx = 0; additional_idx< additionalTiles[i].size(); additional_idx++) {
                List<Integer> t = additionalTiles[i].get(additional_idx);
                int idx = baseTiles.size();
                int previous_idx = idx;
//                int previous_idx = baseTiles.indexOf(t);
//                if (previous_idx == -1) previous_idx = idx;
                mapToEquivalentTile.put(idx, previous_idx);
                baseTiles.add(t);
                baseTileCollision.add(0);

                System.out.println("bank "+i+" base tile TileType: " + additional_idx + " ["+idx+"->"+previous_idx+"]");
                TileType tt = new TileType(idx, -1, 0);
                bankTileTypes[i].add(tt);
            }
        }
        
        // Process the power pellet patterns:
        {
            int map[][] = powerPelletPattern.tiles;
            for(int i = 0;i<NBANKS;i++) {
                int [][]submap = new int[map.length][BANK_HEIGHT[i]];
                for(int x = 0;x<map.length;x++) {
                    for(int y = 0;y<BANK_HEIGHT[i] && BANK_START[i]+y<map[x].length;y++) {
                        submap[x][y] = map[x][BANK_START[i]+y];
                    }
                }
                generateTileTypes(submap, baseTiles, baseTileCollision, usedTiles[i], usedTileTypes[i],
                                  mapToEquivalentTile, bankTileTypes[i], true, animatedTiles);
            }
        }
        
        // Process the regular patterns:
        for(int patternIndex = 0;patternIndex<patterns.size();patternIndex++) {
            Pattern pattern = patterns.get(patternIndex);
            int map[][] = pattern.tiles;
            for(int i = 0;i<NBANKS;i++) {
                int [][]submap = new int[map.length][BANK_HEIGHT[i]];
                for(int x = 0;x<map.length;x++) {
                    for(int y = 0;y<BANK_HEIGHT[i] && BANK_START[i]+y<map[x].length;y++) {
                        submap[x][y] = map[x][BANK_START[i]+y];
                    }
                }
                // int firstCollisionTypes[] = 
                generateTileTypes(submap, baseTiles, baseTileCollision, usedTiles[i],  usedTileTypes[i],
                                  mapToEquivalentTile, bankTileTypes[i], false, animatedTiles);
            }
        }
                

        // List<Integer> usedBaseTilesIndexes = new ArrayList<>();
        List<Integer> dataInstantiatedTiles = new ArrayList<>();
        for(int i = 0;i<NBANKS;i++) {    
            
            System.out.println("Bank " + i + " tile types:");
            for(TileType tt:bankTileTypes[i]) {
                System.out.println("    " + tt);
            }
            
            String outputImageFileName = outputFolder + "/tiles-2px-offset-bank"+i+".png";
            if (outputImageFileName != null) FindAllTiles.saveTilesToPNG(usedTiles[i], outputImageFileName);
            System.out.println("# of tiles needed for horizontal 2 pixel scroll: " + usedTiles[i].size() + " (max: " + (256-RESERVED_TILES_FOR_TEXT[i]) + ")");
            if (usedTiles[i].size() > 256-RESERVED_TILES_FOR_TEXT[i]) {
                throw new Exception("Too many tiles in bank "+i+"!: " + usedTiles[i].size() + " > " + (256-RESERVED_TILES_FOR_TEXT[i]));
            }
            
            // Save the tileTypes for calculating the tiles directly on MSX:
            // System.out.println("Instantiated tiles:");
            dataInstantiatedTiles.add(usedTileTypes[i].size()-1);
            for(InstantiatedTileType itt:usedTileTypes[i]) {
                int t1 = mapToEquivalentTile.get(itt.type.tile);
                int t2 = mapToEquivalentTile.get(itt.type.nextTileH);
                if (t1 == 0 && t2 == 0 && itt.offset == 0) continue;
                if (animatedTiles.containsKey(t1)) {
                    t1 = animatedTiles.get(t1)[itt.offset/2];
                }
                if (animatedTiles.containsKey(t2)) {
                    t2 = animatedTiles.get(t2)[itt.offset/2];
                }
                List<Integer> t1_tile = baseTiles.get(t1);
                List<Integer> t2_tile = baseTiles.get(t2);
                int t1_idx = findTile(usedBaseTiles, t1_tile);
                int t2_idx = findTile(usedBaseTiles, t2_tile);

                if (t1_idx == -1) {
                    t1_idx = usedBaseTiles.size();
                    usedBaseTiles.add(t1_tile);
                }
                if (t2_idx == -1) {
                    t2_idx = usedBaseTiles.size();
                    usedBaseTiles.add(t2_tile);
                }

                informationNeededForInstantiatedTileType(t1_idx, t2_idx, itt.offset, usedBaseTiles, dataInstantiatedTiles);
            }      
            
            if (dataInstantiatedTiles.size() > 2048) throw new Exception("Data too large for the game! " + dataInstantiatedTiles.size());
        }    
        {
            String fileName = outputFolder + "/instantiated-tile-types";
            FileWriter fw = new FileWriter(fileName+".asm");
            Z80Assembler.dataBlockToAssembler(dataInstantiatedTiles, "dataInstantiatedTiles", fw, 16);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }        
        {
            // save an image with the used base tiles:
            System.out.println("usedBaseTiles:  "+usedBaseTiles.size());
            // System.out.println("usedBaseTiles ("+usedBaseTilesIndexes.size()+"): " + usedBaseTilesIndexes);
            FindAllTiles.saveTilesToPNG(usedBaseTiles, outputFolderParent + "/ingame-tiles-used-base.png");
            
            List<Integer> patternsData = new ArrayList<>();
            patternsData.addAll(ConvertNonEmptyPatternsToAssembler.convertToBytes(outputFolderParent + "/ingame-tiles-used-base.png", true));
            String fileName = outputFolderParent + "/ingame-tiles-used-base";
            FileWriter fw = new FileWriter(fileName+".asm");
            Z80Assembler.dataBlockToAssembler(patternsData, "tilesUsedBase", fw, 16);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        {
            // save an image with the additional tiles:
            List<Integer> patternsData = new ArrayList<>();
            patternsData.addAll(ConvertNonEmptyPatternsToAssembler.convertToBytes("data/additional-tiles.png", true));
            String fileName = "src/autogenerated/additional-tiles";
            FileWriter fw = new FileWriter(fileName+".asm");
            Z80Assembler.dataBlockToAssembler(patternsData, "additionalTiles", fw, 16);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});
            APLib.main(fileName + ".bin", fileName + ".apl", true);
        }
        
        
        for(int i = 0;i<NBANKS;i++) {    
            List<Integer> patternsData = new ArrayList<>();
            patternsData.addAll(ConvertNonEmptyPatternsToAssembler.convertToBytes(outputFolder + "/tiles-2px-offset-bank"+i+".png", true));
            String fileName = outputFolder + "/tiles-2px-offset-bank"+i;
            FileWriter fw = new FileWriter(fileName+".asm");
            Z80Assembler.dataBlockToAssembler(patternsData, "patternsData", fw, 16);
            fw.flush();
            fw.close();
        }

        // Adjust the tile types to the pre-defined boundaries, so all levels align:
        for(int i = 0;i<NBANKS;i++) {
            for(int j = 0;j<bankTileTypes[i].size();j++) {
                int collisionType = bankTileTypes[i].get(j).collision;
                if ( j < FIRST_COLLIDABLE_TILE[collisionType] ) {
                    // insert padding:
                    TileType tt = new TileType(0, 0, bankTileTypes[i].get(j-1).collision);
                    tt.tileTableH = new int[]{0,0,0,0};
                    bankTileTypes[i].add(j, tt);
                } 
                if (j >= FIRST_COLLIDABLE_TILE[collisionType+1]) {
                    throw new Exception("Too many tile types in bank " + i + ", of collision type " + collisionType + "!");
                }
            }
        }

        /*
        for(int i = 0;i<NBANKS;i++) {
            System.out.println("Bank " + i);
            for(int j = 0;j<bankTileTypes[i].size();j++) {
                System.out.println(j + "\t" + bankTileTypes[i].get(j).collision);
            }
        }
        */
        
        FileWriter tileType_fw = new FileWriter(outputFolder + "/bankTileTypes.asm");
        for(int i = 0;i<NBANKS;i++) {
            tileType_fw.write("; length: "+bankTileTypes[i].size()+":\n");
            tileType_fw.write("    db " + bankTileTypes[i].size()+"\n");
            for(int j = 0;j<4;j++) {
                tileType_fw.write("bank"+(i+1)+"TileTypes"+j+":\n");
                tileType_fw.write("    db ");
                boolean first = true;
                for(TileType tt:bankTileTypes[i]) {                    
                    if (first) {
                        tileType_fw.write("" + tt.tileTableH[j]);
                        first = false;
                    } else {
                        tileType_fw.write(", " + tt.tileTableH[j]);
                    }
                }
                tileType_fw.write("\n");
            }
            
            if (print_TileTypeTable) {
                System.out.println("Tile Type Table for Bank " + i + ":");
                for(TileType tt:bankTileTypes[i]) {                                
                    System.out.println(tt.tile + "->" + tt.nextTileH + ": " + bankTileTypes[i].indexOf(tt));
                }
            }            
        }
        tileType_fw.close();  
        
        // Compile and compress the data:
        for(int i = 0;i<NBANKS;i++) {
            nl.grauw.glass.Assembler.main(new String[]{outputFolder + "/tiles-2px-offset-bank" + i + ".asm", 
                                                       outputFolder + "/tiles-2px-offset-bank" + i + ".bin"});
            Pletter.intMain(new String[]{outputFolder + "/tiles-2px-offset-bank" + i + ".bin", 
                                         outputFolder + "/tiles-2px-offset-bank" + i + ".plt"});
            APLib.main(outputFolder + "/tiles-2px-offset-bank" + i + ".bin", 
                       outputFolder + "/tiles-2px-offset-bank" + i + ".apl", true);
        }
        
        return bankTileTypes;
    }
        
    
    public static void informationNeededForInstantiatedTileType(
            int t1_idx, int t2_idx, int offset, 
            List<List<Integer>> tiles, List<Integer> dataInstantiatedTiles) throws Exception
    {        
        if (t1_idx >= 240 || t2_idx >= 240) {
            throw new Exception("More than 240 in-game base tiles! " + t1_idx + " - " + t2_idx);
        }
        
        // Construct real shifted tile:
        List<Integer> newTile = new ArrayList<>();
        for(int y = 0;y<8;y++) {
            for(int x = 0;x<8;x++) {
                int x2 = x+offset;
                if (x2<8) {
                    newTile.add(tiles.get(t1_idx).get(y*8 + x2));
                } else {
                    newTile.add(tiles.get(t2_idx).get(y*8 + x2-8));
                }
            }
        }
        List<Integer> newPattern = ConvertNonEmptyPatternsToAssembler.generateAssemblerBitmap(newTile);
        List<Integer> newAttributes = ConvertNonEmptyPatternsToAssembler.generateAssemblerAttributes(newTile);

        List<Integer> t1Pattern = ConvertNonEmptyPatternsToAssembler.generateAssemblerBitmap(tiles.get(t1_idx));
        List<Integer> t1Attributes = ConvertNonEmptyPatternsToAssembler.generateAssemblerAttributes(tiles.get(t1_idx));
        List<Integer> t2Pattern = ConvertNonEmptyPatternsToAssembler.generateAssemblerBitmap(tiles.get(t2_idx));
        List<Integer> t2Attributes = ConvertNonEmptyPatternsToAssembler.generateAssemblerAttributes(tiles.get(t2_idx));
     
        // recreate the simple assembler logic:
        List<Integer> assemblerPattern = new ArrayList<>();
        List<Integer> assemblerAttributes = new ArrayList<>();
        for(int i = 0;i<8;i++) {
            int b1 = (t1Pattern.get(i) << offset) & 0xff;
            int b2 = (t2Pattern.get(i) >> (8-offset)) & 0xff;
            int merged = b1 | b2;
            int merged_attribute = t2Attributes.get(i);
            if (b1 == 0 && b2 == 0) {
                merged_attribute = t1Attributes.get(i) & 0x0f;
            } else if (b1 != 0) {
                merged_attribute = t1Attributes.get(i);
            }
            assemblerPattern.add(merged);
            assemblerAttributes.add(merged_attribute);
        }
        
        // Compare them:
        boolean patternsEqual = true;
        boolean attributesEqual = true;
        for(int i = 0; i<8; i++) {
            if (!newPattern.get(i).equals(assemblerPattern.get(i))) patternsEqual = false;
            if (!newAttributes.get(i).equals(assemblerAttributes.get(i))) attributesEqual = false;
        }
        
        if (offset == 0) {
            dataInstantiatedTiles.add(t1_idx);
            System.out.println(t1_idx);
        } else {
            if (patternsEqual && attributesEqual) {
                dataInstantiatedTiles.add(240+offset/2);
                dataInstantiatedTiles.add(t1_idx);
                dataInstantiatedTiles.add(t2_idx);
                System.out.println((240+offset/2) + "\t" + t1_idx + "\t" + t2_idx);
            } else if (patternsEqual) {
                dataInstantiatedTiles.add(248+offset/2);
                dataInstantiatedTiles.add(t1_idx);
                dataInstantiatedTiles.add(t2_idx);
                for(int i = 0;i<8;i++) {
                    dataInstantiatedTiles.add(newAttributes.get(i));
                }
                System.out.println((248+offset/2) + "\t" + t1_idx + "\t" + t2_idx + "\tattributes");            
            } else {
                dataInstantiatedTiles.add(0xff);
                for(int i = 0;i<8;i++) {
                    dataInstantiatedTiles.add(newPattern.get(i));
                }
                for(int i = 0;i<8;i++) {
                    dataInstantiatedTiles.add(newAttributes.get(i));
                }
                System.out.println("255\tpattern+attributes");
            }
        }
    }
    
    
    public static boolean tilePresent(BufferedImage img, int x, int y)
    {
        for(int i = 0;i<8;i++) {
            for(int j = 0;j<8;j++) {
                int color = img.getRGB(x+j, y+i);
                int a = (color & 0xff000000)>>24;
                if (a != 0) return true;
            }
        }
        return false;
    }
    
    
    public static void findAllTilesWithTypes(
            BufferedImage img, BufferedImage imgCollisions,
            List<List<Integer>> tiles, List<Integer> tileTypes, HashMap<Integer,Integer> mapToEquivalentTile,
            boolean filterTransparent) throws Exception
    {        
        for(int y = 0;y<img.getHeight();y+=8) {
            for(int x = 0;x<img.getWidth();x+=8) {
                if (filterTransparent && !tilePresent(img, x, y)) continue;
                List<Integer> tile = FindAllTiles.getTile(img, x/8, y/8, TOLERANCE);
                int found = -1;
                for(List<Integer> t2:tiles) {
                    boolean equals = true;
                    for(int i = 0;i<tile.size();i++) {
                        if (((int)tile.get(i)) != ((int)t2.get(i))) {
                            equals = false;
                            break;
                        }
                    }
                    if (equals) {
                        found = tiles.indexOf(t2);
                        //System.out.println("    " + tiles.size() + " == " + found);
                        break;
                    }
                }
                if (found == -1) found = tiles.size();
                if (mapToEquivalentTile != null) mapToEquivalentTile.put(tiles.size(), found);
                tiles.add(tile);
                if (imgCollisions != null) {
                    int collisionType = getTileCollisionType(imgCollisions, x, y);
                    tileTypes.add(collisionType);
                }
            }
        }
        if (tileTypes != null) {
            System.out.println("tiles: " + tiles.size());
            System.out.println("tileTypes: " + tileTypes.size());
        }
    }    
    
    
    public static int getTileCollisionType(BufferedImage imgCollisions, int x, int y)
    {
        if (imgCollisions != null) {
            int color = ConvertPatternsToAssembler.findMSXColor(imgCollisions.getRGB(x, y), TOLERANCE);
            switch (color) {
                case 0:
                case -1:
                    return 0;
                case 4:
                    return 1;   // collidable for ship, but not for bullets (DARK BLUE)
                case 15:
                    return 2;   // obstacle (WHITE)
                case 8:
                    return 3;   // destroyable wall (RED)
                default:
                    return 4;   // enemy (GREEN)
            }
        }
        return 0;
    }
    
    
    public static int[] generateTileTypes(int [][]map,
                                         List<List<Integer>> baseTiles, List<Integer> baseTileCollision, 
                                         List<List<Integer>> usedTiles, List<InstantiatedTileType> usedTileTypes, 
                                         HashMap<Integer,Integer> mapToEquivalentTile, 
                                         List<TileType> tileTypes, boolean treatAdditionalFilesDifferently,
                                         HashMap<Integer,int[]> animatedTiles) throws Exception 
    {        
        // find the tile types:
        int firstWithCollision[] = findTileTypes(map, tileTypes, mapToEquivalentTile, baseTileCollision);
        
        System.out.println("TileTypes: " + tileTypes.size());
        // System.out.println("firstWithCollision: " + Arrays.toString(firstWithCollision));
        // for(TileType tt:tileTypes) System.out.println("    " + tt);
        
        // create the tiles with offsets:
        for(TileType tt:tileTypes) {
            //System.out.println("    " + tt.tile + " -> " + tt.nextTileH);
            if (tt.nextTileH >= 0) {
                List<Integer> t1 = constructOffsetTileH(0, tt.tile, tt.nextTileH, baseTiles, animatedTiles, mapToEquivalentTile);
                List<Integer> t2 = constructOffsetTileH(2, tt.tile, tt.nextTileH, baseTiles, animatedTiles, mapToEquivalentTile);
                List<Integer> t3 = constructOffsetTileH(4, tt.tile, tt.nextTileH, baseTiles, animatedTiles, mapToEquivalentTile);
                List<Integer> t4 = constructOffsetTileH(6, tt.tile, tt.nextTileH, baseTiles, animatedTiles, mapToEquivalentTile);
                int idx1 = findOrAddTile(t1, new InstantiatedTileType(tt, 0), usedTiles, usedTileTypes);
                int idx2 = findOrAddTile(t2, new InstantiatedTileType(tt, 2), usedTiles, usedTileTypes);
                int idx3 = findOrAddTile(t3, new InstantiatedTileType(tt, 4), usedTiles, usedTileTypes);
                int idx4 = findOrAddTile(t4, new InstantiatedTileType(tt, 6), usedTiles, usedTileTypes);
                tt.tileTableH = new int[]{idx1, idx2, idx3, idx4};
                //System.out.println("h"+tileTypes.indexOf(tt)+": " + idx1 + ", " + idx2 + ", " + idx3 + ", " + idx4 + " from " + tt.tile + " -> " + tt.nextTileH);
            } else {
                if (treatAdditionalFilesDifferently) {
                    List<Integer> t1 = constructOffsetTileH(0, tt.tile, tt.nextTileH, baseTiles, animatedTiles, mapToEquivalentTile);
                    usedTiles.add(t1);
                    int idx1 = usedTiles.size()-1;
                    tt.tileTableH = new int[]{idx1, idx1, idx1, idx1};                    
                }
            }
        }
        return firstWithCollision;
    }
    
    
    public static TileType getTileType(List<TileType> tileTypes, int tile, int nextTile, HashMap<Integer,Integer> mapToEquivalentTile)
    {
        tile = mapToEquivalentTile.get(tile);
        nextTile = mapToEquivalentTile.get(nextTile);
        for(TileType tt:tileTypes) {
            if (tt.tile == tile && tt.nextTileH == nextTile) return tt;
        }
        return null;
    }
    
    
    public static int[] findTileTypes(int [][]map, List<TileType> tileTypes,
                                     HashMap<Integer,Integer> mapToEquivalentTile,
                                     List<Integer> baseTileCollision)
    {
        int width = map.length;
        int height = map[0].length;

        System.out.println("Processing a map of size: " + width + "*" + height + " with mapToEquivalentTile of size " + mapToEquivalentTile.size());
        /*
        for(int key:mapToEquivalentTile.keySet()) {
            System.out.println("    " + key + " -> " + mapToEquivalentTile.get(key));
        }
        */

        for(int y = 0;y<height;y++) {
            for(int x = 0;x<width-1;x++) {
                int mapTile = map[x][y];
                int nextMapTile = map[x+1][y];
                if (mapTile >= TILE_ENEMY_FIRST_TILE) mapTile = map[x-1][y];
                if (nextMapTile >= TILE_ENEMY_FIRST_TILE) nextMapTile = mapTile;
                // only have a special tile for solid black to solid black:
                if (mapTile != SOLID_BLACK_BG_TILE || nextMapTile != SOLID_BLACK_BG_TILE) {
                    if (mapTile == SOLID_BLACK_BG_TILE) mapTile = 0;
                    if (nextMapTile == SOLID_BLACK_BG_TILE) nextMapTile = 0;
                }
                int tile = mapToEquivalentTile.get(mapTile);
                int nextTileH = mapToEquivalentTile.get(nextMapTile);
                int collision = baseTileCollision.get(tile);
                //if (nextTileH >= 0) collision = Math.max(collision, baseTileCollision.get(nextTileH));
                //System.out.println(x + "," + y + ": " + mapTile + " -> " + nextMapTile + " ----- " + tile + " -> " + nextTileH);
                TileType tt = new TileType(tile, nextTileH, collision);
                if (!tileTypes.contains(tt)) tileTypes.add(tt);
            }
        }
        
        Collections.sort(tileTypes, new Comparator<TileType>() {
            @Override
            public int compare(TileType o1, TileType o2) {
                return Integer.compare(o1.collision, o2.collision);
            }
        });
        for(TileType t:tileTypes) {
            System.out.print(" " + t.collision);
        }
        System.out.println("");
        
        // find collision threshold:
        int firstWithCollision[] = new int[]{tileTypes.size(), tileTypes.size(), tileTypes.size()};
        for(int i = 0;i<tileTypes.size();i++) {
            if (tileTypes.get(i).collision == 1) {
                if (firstWithCollision[0] > i) firstWithCollision[0] = i;
            }
            if (tileTypes.get(i).collision == 2) {
                if (firstWithCollision[1] > i) firstWithCollision[1] = i;
            }
            if (tileTypes.get(i).collision == 3) {
                if (firstWithCollision[2] > i) firstWithCollision[2] = i;
            }
        }
        return firstWithCollision;
    }
    

    public static int findTile(List<List<Integer>> tiles, List<Integer> tile)
    {
        for(int idx = 0; idx<tiles.size(); idx++) {
            List<Integer> tile2 = tiles.get(idx);
            boolean found = true;
            for(int i = 0;i<tile2.size();i++) {
                if (tile2.get(i) != tile.get(i)) {
                    found = false;
                    break;
                }
            }
            if (found) return idx;
        }
        return -1;
    }
    
    
    public static int findOrAddTile(List<Integer> tile, InstantiatedTileType tileType,
                                    List<List<Integer>> usedTiles,
                                    List<InstantiatedTileType> usedTileTypes)
    {
        for(int idx = 0;idx<usedTiles.size();idx++) {
            List<Integer> tile2 = usedTiles.get(idx);
            boolean match = true;
            for(int i = 0;i<tile.size();i++) {
                if (tile.get(i) != tile2.get(i)) {
                    match = false;
                    break;
                }
            }
            if (match) return idx;
        }
            
        usedTiles.add(tile);
        usedTileTypes.add(tileType);
        return usedTiles.size()-1;
    }
    
    
    private static List<Integer> constructOffsetTileH(int offset, int tile, int nextTile, List<List<Integer>> tiles, 
                                                      HashMap<Integer, int[]> animatedTiles,
                                                      HashMap<Integer,Integer> mapToEquivalentTile) {

        if (animatedTiles.containsKey(tile)) {
            //System.out.println("constructOffsetTileH.animatedTile(tile="+tile+") -> " + animatedTiles.get(tile)[offset/2]);
            tile = animatedTiles.get(tile)[offset/2];
        }
        if (animatedTiles.containsKey(nextTile)) {
            //System.out.println("constructOffsetTileH.animatedTile(nextTile="+nextTile+") -> " + animatedTiles.get(nextTile)[offset/2]);
            nextTile = animatedTiles.get(nextTile)[offset/2];
        }
        
        int solid_black_bg_tile = mapToEquivalentTile.get(SOLID_BLACK_BG_TILE);
        if (tile == solid_black_bg_tile) tile = 0;
        if (nextTile == solid_black_bg_tile) nextTile = 0;
        
        if (nextTile == -1) return tiles.get(tile);
        if (offset == 0) return tiles.get(tile);
        if (offset == 8) return tiles.get(nextTile);
        if (offset<0 || offset>8) return null;
        
        List<Integer> newTile = new ArrayList<>();
        for(int y = 0;y<8;y++) {
            for(int x = 0;x<8;x++) {
                int x2 = x+offset;
                if (x2<8) {
                    newTile.add(tiles.get(tile).get(y*8 + x2));
                } else {
                    newTile.add(tiles.get(nextTile).get(y*8 + x2-8));
                }
            }
        }
        
        return newTile;
    }

}
