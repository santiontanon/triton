/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package triton.pcg;

import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import triton.GenerateTileSets;
import triton.GenerateTileSets.TileType;
import util.APLib;
import util.Pletter;
import util.Z80Assembler;

/**
 *
 * @author santi
 */
public class EncodePatternsAndEnemies {
    public static void main(String args[]) throws Exception
    {
        List<List<Integer>> usedBaseTiles = new ArrayList<>();

        List<Pattern> moaiPatterns = LevelPatterns.loadMoaiPatterns();
        encodePatternsAndEnemies("moai", moaiPatterns, usedBaseTiles);

        List<Pattern> techPatterns = LevelPatterns.loadTechPatterns();
        encodePatternsAndEnemies("tech", techPatterns, usedBaseTiles);
        
        List<Pattern> waterPatterns = LevelPatterns.loadWaterPatterns();
        encodePatternsAndEnemies("water", waterPatterns, usedBaseTiles);

        List<Pattern> templePatterns = LevelPatterns.loadTemplePatterns();
        encodePatternsAndEnemies("temple", templePatterns, usedBaseTiles);
    }
        

    public static void encodePatternsAndEnemies(
            String mapTypeName, 
            List<Pattern> patterns,
            List<List<Integer>> usedBaseTiles) throws Exception
    {
        String outputFolder = "src/autogenerated";
        String outputFolderLevel = "src/autogenerated/" + mapTypeName;
        
        HashMap<Integer,Integer> mapToEquivalentTile = new LinkedHashMap<>();
        List<GenerateTileSets.TileType> bankTileTypes[] = GenerateTileSets.generateTileTypes(
                mapToEquivalentTile, usedBaseTiles, mapTypeName);
        
        {
            Pattern powerPelletPattern = new Pattern("data/patterns/power-pellet.tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{});
            int powerPelletTileTypeMap[][] = convertMap(powerPelletPattern.tiles, bankTileTypes, mapToEquivalentTile);
            List<Integer> bytes = new ArrayList<>();
            bytes.add(powerPelletTileTypeMap[0][0]);
            bytes.add(powerPelletTileTypeMap[1][0]);
            bytes.add(powerPelletTileTypeMap[2][0]);
            List<Integer> bytes2 = new ArrayList<>();
            bytes2.add(powerPelletTileTypeMap[0][21]);
            bytes2.add(powerPelletTileTypeMap[1][21]);
            bytes2.add(powerPelletTileTypeMap[2][21]);
            String fileName = outputFolder + "/powerpellet-types.asm";
            FileWriter fw = new FileWriter(fileName);
            Z80Assembler.dataBlockToAssembler(bytes, "power_pellet_types_bank0", fw, 16);
            Z80Assembler.dataBlockToAssembler(bytes2, "power_pellet_types_bank1", fw, 16);
            fw.flush();
            fw.close();
        }
        
        if (mapTypeName.equals("moai")) {
            Pattern destroyableTilesPattern = new Pattern("data/patterns/"+mapTypeName+"-destroyable-tiles.tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{});
            int tileTypeMap[][] = convertMap(destroyableTilesPattern.tiles, bankTileTypes, mapToEquivalentTile);
            List<Integer> bytes = new ArrayList<>();
            bytes.add(tileTypeMap[0][0]);
            bytes.add(tileTypeMap[1][0]);
            bytes.add(tileTypeMap[2][0]);
            List<Integer> bytes2 = new ArrayList<>();
            bytes2.add(tileTypeMap[0][21]);
            bytes2.add(tileTypeMap[1][21]);
            bytes2.add(tileTypeMap[2][21]);
            String fileName = outputFolderLevel + "/destroyable-tiles";
            FileWriter fw = new FileWriter(fileName + ".asm");
            Z80Assembler.dataBlockToAssembler(bytes, "bank0", fw, 16);
            Z80Assembler.dataBlockToAssembler(bytes2, "bank1", fw, 16);
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});            
        }
                
        // Convert each of the patterns:
        int totalPatternSize = 0;
        int totalPatternCompressedSizePletter = 0;
        int totalPatternCompressedSizeAPLib = 0;
        for(Pattern p:patterns) {
            p.randomizeTilesCompressible(mapTypeName);
            //p.randomizeTiles();
            int map[][] = p.tiles;
            int tileTypeMap[][] = convertMap(p.tiles, bankTileTypes, mapToEquivalentTile);
            for(int i = 0;i<GenerateTileSets.NBANKS;i++) {
                // Translate to tile types:
                for(int x = 0;x<map.length-1;x++) {
                    for(int y = 0;y<GenerateTileSets.BANK_HEIGHT[i] && GenerateTileSets.BANK_START[i]+y<map[x].length;y++) {
                        // anything over 250 is a special tile used to mark where to spawn enemies:
                        if (map[x][GenerateTileSets.BANK_START[i]+y] < GenerateTileSets.TILE_ENEMY_FIRST_TILE) {
                            int tile = map[x][GenerateTileSets.BANK_START[i]+y];
                            int next = map[x+1][GenerateTileSets.BANK_START[i]+y];
                            if (next >= GenerateTileSets.TILE_ENEMY_FIRST_TILE) next = tile;
                            
                            // only have a special tile for solid black to solid black:
                            if (tile != GenerateTileSets.SOLID_BLACK_BG_TILE || next != GenerateTileSets.SOLID_BLACK_BG_TILE) {
                                if (tile == GenerateTileSets.SOLID_BLACK_BG_TILE) tile = 0;
                                if (next == GenerateTileSets.SOLID_BLACK_BG_TILE) next = 0;
                            }
                            
                            TileType tt = GenerateTileSets.getTileType(bankTileTypes[i], tile, next, mapToEquivalentTile);
                            if (tt == null) throw new Exception("TileType not found in bank "+i+"!! " + map[x][GenerateTileSets.BANK_START[i]+y] + " -> " + map[x+1][GenerateTileSets.BANK_START[i]+y]);
                            tileTypeMap[x][GenerateTileSets.BANK_START[i]+y] = bankTileTypes[i].indexOf(tt);
                        } else {
                            // enemy markers:
                            tileTypeMap[x][GenerateTileSets.BANK_START[i]+y] = map[x][GenerateTileSets.BANK_START[i]+y];
                        }
                    }
                }                
            }
            
            // Save and Compress:
            List<Integer> bytes = new ArrayList<>();
            for(int y = 0;y<tileTypeMap[0].length;y++) {
                for(int x = 0;x<tileTypeMap.length-1;x++) {
                    bytes.add(tileTypeMap[x][y]);
                }
            }
            
            // enemy waves:
            if (p.enemyWaves.length != 4) throw new Exception("the number of enemy waves per pattern should be 4!");
            for(int ew:p.enemyWaves) {
                bytes.add(ew);
            }
            
            System.out.println("Raw size: " + bytes.size());
            System.out.println("Pletter size: " + Pletter.sizeOfCompressedBuffer(bytes));
            String fileName = outputFolderLevel + "/pattern-" + patterns.indexOf(p);
            FileWriter fw = new FileWriter(fileName + ".asm");
            Z80Assembler.dataBlockToAssembler(bytes, "pattern", fw, map.length-1);
            fw.flush();
            fw.close();
            
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            int sizePletter = Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});
            int sizeAPLib = APLib.main(fileName + ".bin", fileName + ".apl", true);
            
            totalPatternSize += bytes.size();
            totalPatternCompressedSizePletter += sizePletter;
            totalPatternCompressedSizeAPLib += sizeAPLib;
        }
        
        // Compress all the patterns together:
        for(String type:new String[]{"plt","apl"}) {
            String fileName = outputFolderLevel + "/patterns-all";
            FileWriter fw = new FileWriter(fileName + ".asm");
            fw.write("    org #C400\n");
            fw.write("pcgPatterns:\n");
            for(int i = 0;i<patterns.size();i++) {
                Pattern p = patterns.get(i);
                fw.write("    db " + (p.leftConstraint+1) + "," + (p.rightConstraint+1) + "\n");
                fw.write("    dw pcgPattern" + i + "\n");
            }        
            fw.write("    db 0\n");
            for(int i = 0;i<patterns.size();i++) {
                fw.write("pcgPattern" + i + ":\n");
                // notice that we compress the .plt ones even with APL, as it turns out
                // that we gain more space doing that than the space that it takes to have pletter also in the code!
                // so, we will have both compressors in the code
                fw.write("    incbin \"pattern-" + i + ".plt\"\n"); 
            }
            fw.flush();
            fw.close();
            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            if (type.equals("plt")) {
                Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});
            } else {
                APLib.main(fileName + ".bin", fileName + ".apl", true);
            }
        }
            
        // Convert the enemy data:
        for(int i = 0;i<GenerateTileSets.NBANKS;i++) {
            List<Pattern> enemyPatterns = new ArrayList<>();
            if (mapTypeName.equals("moai")) {
                enemyPatterns.add(new Pattern("data/patterns/enemy-turret-moai-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                enemyPatterns.add(new Pattern("data/patterns/enemy-moai-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
            } else if (mapTypeName.equals("tech")) {
                enemyPatterns.add(new Pattern("data/patterns/enemy-turret-tech-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                enemyPatterns.add(new Pattern("data/patterns/enemy-generator-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
            } else if (mapTypeName.equals("water")) {
                enemyPatterns.add(new Pattern("data/patterns/enemy-turret-water-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                enemyPatterns.add(new Pattern("data/patterns/enemy-water-dome-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
            } else if (mapTypeName.equals("temple")) {
                enemyPatterns.add(new Pattern("data/patterns/enemy-turret-temple-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                if (i==0) {
                    enemyPatterns.add(new Pattern("data/patterns/enemy-temple-snake-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                } else {
                    enemyPatterns.add(new Pattern("data/patterns/enemy-temple-column-bank"+i+".tmx", Pattern.EMPTY, Pattern.EMPTY, new int[]{}));
                }
            }
            List<Integer> bytes = new ArrayList<>();
            for(Pattern p:enemyPatterns) {
                int map[][] = p.tiles;
                int tileTypeMap[][] = new int[map.length][map[0].length];
                // Translate to tile types:
                for(int x = 0;x<map.length;x++) {
                    for(int y = 0;y<map[x].length;y++) {
                        // anything over 252 is a special tile used to mark where to spawn enemies:
                        int tile = map[x][y];
                        int next = 0;
                        if (tile == GenerateTileSets.SOLID_BLACK_BG_TILE) tile = 0;
                        if (x < map.length-1) {
                            next = map[x+1][y];
                        }
                        TileType tt = GenerateTileSets.getTileType(bankTileTypes[i], tile, next, mapToEquivalentTile);
                        if (tt == null) throw new Exception("TileType not found in bank "+i+"!! " + map[x][y] + " -> " + map[x+1][y]);
                        tileTypeMap[x][y] = bankTileTypes[i].indexOf(tt);
                    }
                }                
                for(int y = 0;y<tileTypeMap[0].length;y++) {
                    for(int x = 0;x<tileTypeMap.length;x++) {
                        bytes.add(tileTypeMap[x][y]);
                    }
                }
            }

            // Save and Compress:
            System.out.println("Raw size: " + bytes.size());
            System.out.println("Pletter size: " + Pletter.sizeOfCompressedBuffer(bytes));
            String fileName = outputFolderLevel + "/enemies-bank" + i;
            FileWriter fw = new FileWriter(fileName + ".asm");
            Z80Assembler.dataBlockToAssembler(bytes, "pattern", fw, 16);
            fw.flush();
            fw.close();

            nl.grauw.glass.Assembler.main(new String[]{fileName + ".asm", fileName + ".bin"});
            // Pletter.intMain(new String[]{fileName + ".bin", fileName + ".plt"});            
        }
        
        System.out.println("Total pattern size: " + totalPatternSize);
        System.out.println("Total pattern compressed size (pletter): " + totalPatternCompressedSizePletter);
        System.out.println("Total pattern compressed size (APLib): " + totalPatternCompressedSizeAPLib);
    }    
    
    
    public static int[][] convertMap(int map[][], List<TileType> bankTileTypes[],
                                     HashMap<Integer,Integer> mapToEquivalentTile) throws Exception {
        int tileTypeMap[][] = new int[map.length][map[0].length];
        for(int i = 0;i<GenerateTileSets.NBANKS;i++) {
            // Translate to tile types:
            for(int x = 0;x<map.length-1;x++) {
                for(int y = 0;y<GenerateTileSets.BANK_HEIGHT[i] && GenerateTileSets.BANK_START[i]+y<map[x].length;y++) {
                    // anything over 252 is a special tile used to mark where to spawn enemies:
                    if (map[x][GenerateTileSets.BANK_START[i]+y] < GenerateTileSets.TILE_ENEMY_FIRST_TILE) {
                        int tile = map[x][GenerateTileSets.BANK_START[i]+y];
                        int next = map[x+1][GenerateTileSets.BANK_START[i]+y];
                        if (next >= GenerateTileSets.TILE_ENEMY_FIRST_TILE) next = tile;
                        
                        // only have a special tile for solid black to solid black:
                        if (tile != GenerateTileSets.SOLID_BLACK_BG_TILE || next != GenerateTileSets.SOLID_BLACK_BG_TILE) {
                            if (tile == GenerateTileSets.SOLID_BLACK_BG_TILE) tile = 0;
                            if (next == GenerateTileSets.SOLID_BLACK_BG_TILE) next = 0;
                        }
                        
                        TileType tt = GenerateTileSets.getTileType(bankTileTypes[i], tile, next, mapToEquivalentTile);
                        if (tt == null) {
                            // for(TileType tt2:bankTileTypes[i]) System.out.println(tt2);
                            // System.err.println("240 is mapped to: " + mapToEquivalentTile.get(240));
                            throw new Exception("TileType not found in bank "+i+"!! " + map[x][GenerateTileSets.BANK_START[i]+y] + " -> " + map[x+1][GenerateTileSets.BANK_START[i]+y]);
                        }
                        tileTypeMap[x][GenerateTileSets.BANK_START[i]+y] = bankTileTypes[i].indexOf(tt);
                    } else {
                        // enemy markers:
                        tileTypeMap[x][GenerateTileSets.BANK_START[i]+y] = map[x][GenerateTileSets.BANK_START[i]+y];
                    }
                }
            }                
        }
        return tileTypeMap;
    }
}
